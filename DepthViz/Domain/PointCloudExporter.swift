//
//  PointCloudExporter.swift
//  DepthViz
//
//  ë‹¤ì–‘í•œ íŒŒì¼ í˜•ì‹ìœ¼ë¡œ Point Cloudë¥¼ ë‚´ë³´ë‚´ëŠ” ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤
//

import Foundation
import Metal
import simd

/// Point Cloudë¥¼ ë‹¤ì–‘í•œ íŒŒì¼ í˜•ì‹ìœ¼ë¡œ ë‚´ë³´ë‚´ëŠ” ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤
final class PointCloudExporter {
    
    /// í¬ì¸íŠ¸ ë°ì´í„° ë°°ì—´ì„ ì§ì ‘ íŒŒì¼ë¡œ ë‚´ë³´ëƒ„ (DV-SLAM ë“± ì™¸ë¶€ ë°ì´í„°ìš©)
    static func export(points: [SIMD3<Float>], colors: [SIMD3<UInt8>], format: FileFormat, to url: URL) throws {
        // ì„ì‹œ íŒŒì¼ ìƒì„± ë¡œì§ (ê¸°ì¡´ exportTo...String í•¨ìˆ˜ë“¤ì€ Renderer ì˜ì¡´ì ì´ë¯€ë¡œ ì¬ì‚¬ìš© ë¶ˆê°€)
        // ì—¬ê¸°ì„œëŠ” ê°„ë‹¨í•˜ê²Œ ì§ì ‘ êµ¬í˜„
        
        let pointCount = points.count
        var data = Data()
        
        switch format {
        case .plyAscii:
            appendLine("ply", to: &data)
            appendLine("format ascii 1.0", to: &data)
            appendLine("comment Generated by DepthViz", to: &data)
            appendLine("element vertex \(pointCount)", to: &data)
            appendLine("property float x", to: &data)
            appendLine("property float y", to: &data)
            appendLine("property float z", to: &data)
            appendLine("property uchar red", to: &data)
            appendLine("property uchar green", to: &data)
            appendLine("property uchar blue", to: &data)
            appendLine("end_header", to: &data)

            for i in 0..<pointCount {
                let p = points[i]
                let c = i < colors.count ? colors[i] : SIMD3<UInt8>(255, 255, 255)
                let line = String(format: "%.6f %.6f %.6f %d %d %d", p.x, p.y, p.z, c.x, c.y, c.z)
                appendLine(line, to: &data)
            }
            
        case .plyBinary:
            let header = "ply\nformat binary_little_endian 1.0\ncomment Generated by DepthViz\nelement vertex \(pointCount)\nproperty float x\nproperty float y\nproperty float z\nproperty uchar red\nproperty uchar green\nproperty uchar blue\nend_header\n"
            let headerBytes = header.data(using: .utf8)!
            // Pre-allocate exact size
            data = Data(count: headerBytes.count + pointCount * 15)
            data.replaceSubrange(0..<headerBytes.count, with: headerBytes)
            data.withUnsafeMutableBytes { rawPtr in
                guard let base = rawPtr.baseAddress else { return }
                var offset = headerBytes.count
                for i in 0..<pointCount {
                    var p = points[i]
                    let c = i < colors.count ? colors[i] : SIMD3<UInt8>(255, 255, 255)
                    memcpy(base + offset, &p, 12); offset += 12
                    (base + offset).storeBytes(of: c.x, as: UInt8.self); offset += 1
                    (base + offset).storeBytes(of: c.y, as: UInt8.self); offset += 1
                    (base + offset).storeBytes(of: c.z, as: UInt8.self); offset += 1
                }
            }
            
        case .xyz:
            for i in 0..<pointCount {
                let p = points[i]
                let c = i < colors.count ? colors[i] : SIMD3<UInt8>(255, 255, 255)
                let line = String(format: "%.6f %.6f %.6f %d %d %d", p.x, p.y, p.z, c.x, c.y, c.z)
                appendLine(line, to: &data)
            }
            
        case .las:
            // LAS 1.2 Format 2 (with RGB)
            let scale = 0.01

            // Compute bounding box
            var minX = Double.greatestFiniteMagnitude, maxX = -Double.greatestFiniteMagnitude
            var minY = Double.greatestFiniteMagnitude, maxY = -Double.greatestFiniteMagnitude
            var minZ = Double.greatestFiniteMagnitude, maxZ = -Double.greatestFiniteMagnitude
            for p in points {
                let x = Double(p.x); let y = Double(p.y); let z = Double(p.z)
                minX = min(minX, x); maxX = max(maxX, x)
                minY = min(minY, y); maxY = max(maxY, y)
                minZ = min(minZ, z); maxZ = max(maxZ, z)
            }
            if points.isEmpty { minX = 0; maxX = 0; minY = 0; maxY = 0; minZ = 0; maxZ = 0 }

            // Build 227-byte LAS header
            var header = Data(count: 227)
            "LASF".data(using: .ascii)?.withUnsafeBytes { header.replaceSubrange(0..<4, with: $0) }
            // Version 1.2
            header[24] = 1; header[25] = 2
            // System Identifier (offset 26, 32 bytes)
            let sysID = "DepthViz".padding(toLength: 32, withPad: "\0", startingAt: 0)
            sysID.data(using: .ascii)?.withUnsafeBytes { header.replaceSubrange(26..<58, with: Data($0).prefix(32)) }
            // Generating Software (offset 58, 32 bytes)
            let sw = "DepthViz Scanner".padding(toLength: 32, withPad: "\0", startingAt: 0)
            sw.data(using: .ascii)?.withUnsafeBytes { header.replaceSubrange(58..<90, with: Data($0).prefix(32)) }
            // Creation day/year
            let cal = Calendar.current
            var day16 = UInt16(cal.ordinality(of: .day, in: .year, for: Date()) ?? 1)
            var year16 = UInt16(cal.component(.year, from: Date()))
            header.replaceSubrange(90..<92, with: Data(bytes: &day16, count: 2))
            header.replaceSubrange(92..<94, with: Data(bytes: &year16, count: 2))
            // Header size + offset to points
            var hs: UInt16 = 227; header.replaceSubrange(94..<96, with: Data(bytes: &hs, count: 2))
            var otp: UInt32 = 227; header.replaceSubrange(96..<100, with: Data(bytes: &otp, count: 4))
            // VLR count = 0
            var vlr: UInt32 = 0; header.replaceSubrange(100..<104, with: Data(bytes: &vlr, count: 4))
            // Point format 2, record length 26
            header[104] = 2
            var prl: UInt16 = 26; header.replaceSubrange(105..<107, with: Data(bytes: &prl, count: 2))
            // Number of points
            var np = UInt32(pointCount); header.replaceSubrange(107..<111, with: Data(bytes: &np, count: 4))
            // Points by return
            var pbr = [UInt32](repeating: 0, count: 5); pbr[0] = np
            header.replaceSubrange(111..<131, with: Data(bytes: pbr, count: 20))
            // Scale factors
            var xs = scale; header.replaceSubrange(131..<139, with: Data(bytes: &xs, count: 8))
            var ys = scale; header.replaceSubrange(139..<147, with: Data(bytes: &ys, count: 8))
            var zs = scale; header.replaceSubrange(147..<155, with: Data(bytes: &zs, count: 8))
            // Offsets = 0
            var zero = 0.0
            header.replaceSubrange(155..<163, with: Data(bytes: &zero, count: 8))
            header.replaceSubrange(163..<171, with: Data(bytes: &zero, count: 8))
            header.replaceSubrange(171..<179, with: Data(bytes: &zero, count: 8))
            // Bounding box
            header.replaceSubrange(179..<187, with: Data(bytes: &maxX, count: 8))
            header.replaceSubrange(187..<195, with: Data(bytes: &minX, count: 8))
            header.replaceSubrange(195..<203, with: Data(bytes: &maxY, count: 8))
            header.replaceSubrange(203..<211, with: Data(bytes: &minY, count: 8))
            header.replaceSubrange(211..<219, with: Data(bytes: &maxZ, count: 8))
            header.replaceSubrange(219..<227, with: Data(bytes: &minZ, count: 8))

            data.append(header)
            data.reserveCapacity(227 + pointCount * 26)

            // Point records (Format 2: 26 bytes each)
            for i in 0..<pointCount {
                let p = points[i]
                var xI = Int32(Double(p.x) / scale)
                var yI = Int32(Double(p.y) / scale)
                var zI = Int32(Double(p.z) / scale)
                withUnsafeBytes(of: &xI) { data.append(contentsOf: $0) }
                withUnsafeBytes(of: &yI) { data.append(contentsOf: $0) }
                withUnsafeBytes(of: &zI) { data.append(contentsOf: $0) }
                // Intensity
                var intensity: UInt16 = 255
                withUnsafeBytes(of: &intensity) { data.append(contentsOf: $0) }
                // Return flags, classification, scan angle, user data
                data.append(contentsOf: [0x01, 1, 0, 0] as [UInt8])
                // Point source ID
                var psid: UInt16 = 0
                withUnsafeBytes(of: &psid) { data.append(contentsOf: $0) }
                // RGB (UInt16 each)
                let c = i < colors.count ? colors[i] : SIMD3<UInt8>(255, 255, 255)
                var r16 = UInt16(c.x) * 257  // Map 0-255 to 0-65535
                var g16 = UInt16(c.y) * 257
                var b16 = UInt16(c.z) * 257
                withUnsafeBytes(of: &r16) { data.append(contentsOf: $0) }
                withUnsafeBytes(of: &g16) { data.append(contentsOf: $0) }
                withUnsafeBytes(of: &b16) { data.append(contentsOf: $0) }
            }
        }
        
        try data.write(to: url)
    }

    /// ì„ íƒí•œ íŒŒì¼ í˜•ì‹ì— ë”°ë¼ Point Cloudë¥¼ ë‚´ë³´ëƒ„
    /// - Parameters:
    ///   - renderer: Renderer ê°ì²´
    /// - Returns: íŒŒì¼ ë°ì´í„° (Data) ë˜ëŠ” nil
    static func export(renderer: Renderer, format: FileFormat) -> Data? {
        let pointCount = renderer.currentPointCount
        
        switch format {
        case .plyAscii:
            return exportToPLYASCII(renderer: renderer, pointCount: pointCount)
        case .plyBinary:
            return exportToPLYBinary(renderer: renderer, pointCount: pointCount)
        case .xyz:
            return exportToXYZ(renderer: renderer, pointCount: pointCount)
        case .las:
            return exportToLAS(renderer: renderer, pointCount: pointCount)
        }
    }
    
    /// ì„ íƒí•œ íŒŒì¼ í˜•ì‹ì— ë”°ë¼ Point Cloudë¥¼ ë¬¸ìì—´ë¡œ ë‚´ë³´ëƒ„ (ASCII í˜•ì‹ìš©)
    /// - Parameters:
    ///   - renderer: Renderer ê°ì²´
    /// - Returns: íŒŒì¼ ë¬¸ìì—´ ë˜ëŠ” nil
    static func exportAsString(renderer: Renderer, format: FileFormat) -> String? {
        let pointCount = renderer.currentPointCount
        
        switch format {
        case .plyAscii:
            return exportToPLYASCIIString(renderer: renderer, pointCount: pointCount)
        case .xyz:
            return exportToXYZString(renderer: renderer, pointCount: pointCount)
        case .plyBinary, .las:
            // Binary í˜•ì‹ì€ ë¬¸ìì—´ë¡œ ë³€í™˜í•  ìˆ˜ ì—†ìŒ
            return nil
        }
    }
    
    // MARK: - PLY ASCII
    
    private static func exportToPLYASCII(renderer: Renderer, pointCount: Int) -> Data? {
        guard let string = exportToPLYASCIIString(renderer: renderer, pointCount: pointCount) else {
            return nil
        }
        return string.data(using: .utf8)
    }
    
    private static func exportToPLYASCIIString(renderer: Renderer, pointCount: Int) -> String? {
        let startTime = CFAbsoluteTimeGetCurrent()
        print("ğŸ“ PLY ASCII íŒŒì¼ ìƒì„± ì‹œì‘...")

        var data = Data()
        data.reserveCapacity((pointCount + 10) * 64)

        appendLine("ply", to: &data)
        appendLine("format ascii 1.0", to: &data)
        appendLine("comment Generated by DepthViz", to: &data)
        appendLine("element vertex \(pointCount)", to: &data)
        appendLine("property float x", to: &data)
        appendLine("property float y", to: &data)
        appendLine("property float z", to: &data)
        appendLine("property uchar red", to: &data)
        appendLine("property uchar green", to: &data)
        appendLine("property uchar blue", to: &data)
        appendLine("end_header", to: &data)

        let startInverse = renderer.getStartCameraTransform()?.inverse
        renderParticles(renderer: renderer, count: pointCount) { index, particle in
            let position = transformPosition(particle.position, with: startInverse)
            let colors = particle.color
            let red = clampColorComponent(colors.x)
            let green = clampColorComponent(colors.y)
            let blue = clampColorComponent(colors.z)
            let line = String(format: "%.6f %.6f %.6f %d %d %d", position.x, position.y, position.z, red, green, blue)
            appendLine(line, to: &data)
        }

        let elapsed = CFAbsoluteTimeGetCurrent() - startTime
        print("âœ… PLY ASCII ì™„ë£Œ â€” \(String(format: "%.2f", elapsed))ì´ˆ")

        return String(data: data, encoding: .utf8)
    }
    
    // MARK: - PLY Binary
    
    private static func exportToPLYBinary(renderer: Renderer, pointCount: Int) -> Data? {
        let startTime = CFAbsoluteTimeGetCurrent()
        print("ğŸ“ PLY Binary íŒŒì¼ ìƒì„± ì‹œì‘ (\(pointCount) points)...")

        // Build header
        let header = "ply\nformat binary_little_endian 1.0\ncomment Generated by DepthViz\nelement vertex \(pointCount)\nproperty float x\nproperty float y\nproperty float z\nproperty uchar red\nproperty uchar green\nproperty uchar blue\nend_header\n"
        guard let headerData = header.data(using: .utf8) else { return nil }

        // Pre-allocate exact size: header + 15 bytes per point (3 floats + 3 bytes)
        let bytesPerPoint = 15
        var data = Data(count: headerData.count + pointCount * bytesPerPoint)

        // Copy header
        data.replaceSubrange(0..<headerData.count, with: headerData)

        let startInverse = renderer.getStartCameraTransform()?.inverse

        // Bulk write â€” direct memory access, no per-point Data.append
        data.withUnsafeMutableBytes { rawPtr in
            guard let base = rawPtr.baseAddress else { return }
            var offset = headerData.count

            renderer.particlesBuffer.withUnsafeBufferPointer { buffer in
                let count = min(pointCount, buffer.count)
                for i in 0..<count {
                    let particle = buffer[i]
                    let pos = transformPosition(particle.position, with: startInverse)

                    var x = Float32(pos.x), y = Float32(pos.y), z = Float32(pos.z)
                    memcpy(base + offset, &x, 4); offset += 4
                    memcpy(base + offset, &y, 4); offset += 4
                    memcpy(base + offset, &z, 4); offset += 4

                    let colors = particle.color
                    (base + offset).storeBytes(of: UInt8(max(0, min(1, colors.x)) * 255), as: UInt8.self); offset += 1
                    (base + offset).storeBytes(of: UInt8(max(0, min(1, colors.y)) * 255), as: UInt8.self); offset += 1
                    (base + offset).storeBytes(of: UInt8(max(0, min(1, colors.z)) * 255), as: UInt8.self); offset += 1
                }
            }
        }

        let elapsed = CFAbsoluteTimeGetCurrent() - startTime
        print("âœ… PLY Binary ì™„ë£Œ â€” \(String(format: "%.2f", elapsed))ì´ˆ, \(data.count) bytes")
        return data
    }
    
    // MARK: - XYZ
    
    private static func exportToXYZ(renderer: Renderer, pointCount: Int) -> Data? {
        guard let string = exportToXYZString(renderer: renderer, pointCount: pointCount) else {
            return nil
        }
        return string.data(using: .utf8)
    }
    
    private static func exportToXYZString(renderer: Renderer, pointCount: Int) -> String? {
        let startTime = CFAbsoluteTimeGetCurrent()
        print("ğŸ“ XYZ íŒŒì¼ ìƒì„± ì‹œì‘...")

        // XYZ format: x y z r g b (no header, space-separated)
        var data = Data()
        data.reserveCapacity(pointCount * 48)

        let startInverse = renderer.getStartCameraTransform()?.inverse
        renderParticles(renderer: renderer, count: pointCount) { _, particle in
            let position = transformPosition(particle.position, with: startInverse)
            let colors = particle.color
            let red = clampColorComponent(colors.x)
            let green = clampColorComponent(colors.y)
            let blue = clampColorComponent(colors.z)
            let line = String(format: "%.6f %.6f %.6f %d %d %d", position.x, position.y, position.z, red, green, blue)
            appendLine(line, to: &data)
        }

        let elapsed = CFAbsoluteTimeGetCurrent() - startTime
        print("âœ… XYZ ì™„ë£Œ â€” \(String(format: "%.2f", elapsed))ì´ˆ")

        return String(data: data, encoding: .utf8)
    }
    
    // MARK: - LAS
    
    /// LAS í¬ë§·: LiDAR ë°ì´í„°ì˜ í‘œì¤€ ë°”ì´ë„ˆë¦¬ í¬ë§·
    private static func exportToLAS(renderer: Renderer, pointCount: Int) -> Data? {
        let startTime = CFAbsoluteTimeGetCurrent()
        print("ğŸ“ LAS íŒŒì¼ ìƒì„± ì‹œì‘...")
        
        // LAS í¬ë§·ì€ ë³µì¡í•œ ë°”ì´ë„ˆë¦¬ í¬ë§·ì´ë¯€ë¡œ ê°„ë‹¨í•œ êµ¬í˜„ ì œê³µ
        // ì‹¤ì œ LAZëŠ” LASë¥¼ ì••ì¶•í•œ ê²ƒì´ë¯€ë¡œ, ì—¬ê¸°ì„œëŠ” LAS í˜•ì‹ìœ¼ë¡œ ì €ì¥
        // ë‚˜ì¤‘ì— ì••ì¶• ë¼ì´ë¸ŒëŸ¬ë¦¬(ì˜ˆ: LASzip)ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŒ
        
        var data = Data()
        
        // LAS íŒŒì¼ í—¤ë” (Public Header Block - 227 bytes)
        // ê°„ë‹¨í•œ êµ¬í˜„ì„ ìœ„í•´ ìµœì†Œí•œì˜ í—¤ë”ë§Œ ì‘ì„±
        var header = Data(count: 227)
        
        // File Signature "LASF" (4 bytes, offset 0)
        "LASF".data(using: .ascii)?.withUnsafeBytes { bytes in
            header.replaceSubrange(0..<4, with: bytes)
        }
        
        // File Source ID (2 bytes, offset 4)
        var sourceID: UInt16 = 0
        header.replaceSubrange(4..<6, with: Data(bytes: &sourceID, count: 2))
        
        // Global Encoding (2 bytes, offset 6)
        var globalEncoding: UInt16 = 0
        header.replaceSubrange(6..<8, with: Data(bytes: &globalEncoding, count: 2))
        
        // Project ID GUID (16 bytes, offset 8) - ëª¨ë‘ 0
        header.replaceSubrange(8..<24, with: Data(count: 16))
        
        // Version Major (1 byte, offset 24)
        var versionMajor: UInt8 = 1
        header.replaceSubrange(24..<25, with: Data(bytes: &versionMajor, count: 1))
        
        // Version Minor (1 byte, offset 25)
        var versionMinor: UInt8 = 2
        header.replaceSubrange(25..<26, with: Data(bytes: &versionMinor, count: 1))
        
        // System Identifier (32 bytes, offset 26) - "DepthViz"
        let systemID = "DepthViz".padding(toLength: 32, withPad: "\0", startingAt: 0)
        systemID.data(using: .ascii)?.withUnsafeBytes { bytes in
            header.replaceSubrange(26..<58, with: bytes.prefix(32))
        }
        
        // Generating Software (32 bytes, offset 58)
        let software = "DepthViz Scanner".padding(toLength: 32, withPad: "\0", startingAt: 0)
        software.data(using: .ascii)?.withUnsafeBytes { bytes in
            header.replaceSubrange(58..<90, with: bytes.prefix(32))
        }
        
        // File Creation Day of Year (2 bytes, offset 90)
        let calendar = Calendar.current
        let dayOfYear = calendar.ordinality(of: .day, in: .year, for: Date()) ?? 1
        var dayOfYearUInt16 = UInt16(dayOfYear)
        header.replaceSubrange(90..<92, with: Data(bytes: &dayOfYearUInt16, count: 2))
        
        // File Creation Year (2 bytes, offset 92)
        var year = UInt16(calendar.component(.year, from: Date()))
        header.replaceSubrange(92..<94, with: Data(bytes: &year, count: 2))
        
        // Header Size (2 bytes, offset 94)
        var headerSize: UInt16 = 227
        header.replaceSubrange(94..<96, with: Data(bytes: &headerSize, count: 2))
        
        // Offset to point data (4 bytes, offset 96)
        var offsetToPoints: UInt32 = 227
        header.replaceSubrange(96..<100, with: Data(bytes: &offsetToPoints, count: 4))
        
        // Number of Variable Length Records (4 bytes, offset 100)
        var numVLR: UInt32 = 0
        header.replaceSubrange(100..<104, with: Data(bytes: &numVLR, count: 4))
        
        // Point Data Format ID (1 byte, offset 104) - Format 2 (RGB ì»¬ëŸ¬ í¬í•¨)
        var pointFormat: UInt8 = 2
        header.replaceSubrange(104..<105, with: Data(bytes: &pointFormat, count: 1))
        
        // Point Data Record Length (2 bytes, offset 105)
        var pointRecordLength: UInt16 = 26  // Format 2ëŠ” 26 bytes (RGB í¬í•¨)
        header.replaceSubrange(105..<107, with: Data(bytes: &pointRecordLength, count: 2))
        
        // Number of point records (4 bytes, offset 107)
        var numPoints = UInt32(pointCount)
        header.replaceSubrange(107..<111, with: Data(bytes: &numPoints, count: 4))
        
        // Number of points by return (5 x 4 bytes, offset 111)
        var numPointsByReturn = [UInt32](repeating: 0, count: 5)
        numPointsByReturn[0] = numPoints  // ëª¨ë“  í¬ì¸íŠ¸ëŠ” ì²« ë²ˆì§¸ returnìœ¼ë¡œ ì„¤ì •
        header.replaceSubrange(111..<131, with: Data(bytes: numPointsByReturn, count: 20))
        
        // X scale factor (8 bytes, offset 131)
        var xScale: Double = 0.01
        header.replaceSubrange(131..<139, with: Data(bytes: &xScale, count: 8))
        
        // Y scale factor (8 bytes, offset 139)
        var yScale: Double = 0.01
        header.replaceSubrange(139..<147, with: Data(bytes: &yScale, count: 8))
        
        // Z scale factor (8 bytes, offset 147)
        var zScale: Double = 0.01
        header.replaceSubrange(147..<155, with: Data(bytes: &zScale, count: 8))
        
        // X offset (8 bytes, offset 155)
        var xOffset: Double = 0.0
        header.replaceSubrange(155..<163, with: Data(bytes: &xOffset, count: 8))
        
        // Y offset (8 bytes, offset 163)
        var yOffset: Double = 0.0
        header.replaceSubrange(163..<171, with: Data(bytes: &yOffset, count: 8))
        
        // Z offset (8 bytes, offset 171)
        var zOffset: Double = 0.0
        header.replaceSubrange(171..<179, with: Data(bytes: &zOffset, count: 8))
        
        // Max X (8 bytes, offset 179)
        var maxX: Double = 0.0
        header.replaceSubrange(179..<187, with: Data(bytes: &maxX, count: 8))
        
        // Min X (8 bytes, offset 187)
        var minX: Double = 0.0
        header.replaceSubrange(187..<195, with: Data(bytes: &minX, count: 8))
        
        // Max Y (8 bytes, offset 195)
        var maxY: Double = 0.0
        header.replaceSubrange(195..<203, with: Data(bytes: &maxY, count: 8))
        
        // Min Y (8 bytes, offset 203)
        var minY: Double = 0.0
        header.replaceSubrange(203..<211, with: Data(bytes: &minY, count: 8))
        
        // Max Z (8 bytes, offset 211)
        var maxZ: Double = 0.0
        header.replaceSubrange(211..<219, with: Data(bytes: &maxZ, count: 8))
        
        // Min Z (8 bytes, offset 219)
        var minZ: Double = 0.0
        header.replaceSubrange(219..<227, with: Data(bytes: &minZ, count: 8))
        
        // ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚° ë° ì„¤ì •
        var minXVal = Float.greatestFiniteMagnitude
        var maxXVal = -Float.greatestFiniteMagnitude
        var minYVal = Float.greatestFiniteMagnitude
        var maxYVal = -Float.greatestFiniteMagnitude
        var minZVal = Float.greatestFiniteMagnitude
        var maxZVal = -Float.greatestFiniteMagnitude
        
        let startInverse = renderer.getStartCameraTransform()?.inverse
        renderParticles(renderer: renderer, count: pointCount) { _, particle in
            let pos = transformPosition(particle.position, with: startInverse)
            minXVal = min(minXVal, pos.x)
            maxXVal = max(maxXVal, pos.x)
            minYVal = min(minYVal, pos.y)
            maxYVal = max(maxYVal, pos.y)
            minZVal = min(minZVal, pos.z)
            maxZVal = max(maxZVal, pos.z)
        }
        
        minX = Double(minXVal)
        maxX = Double(maxXVal)
        minY = Double(minYVal)
        maxY = Double(maxYVal)
        minZ = Double(minZVal)
        maxZ = Double(maxZVal)
        
        header.replaceSubrange(179..<187, with: Data(bytes: &maxX, count: 8))
        header.replaceSubrange(187..<195, with: Data(bytes: &minX, count: 8))
        header.replaceSubrange(195..<203, with: Data(bytes: &maxY, count: 8))
        header.replaceSubrange(203..<211, with: Data(bytes: &minY, count: 8))
        header.replaceSubrange(211..<219, with: Data(bytes: &maxZ, count: 8))
        header.replaceSubrange(219..<227, with: Data(bytes: &minZ, count: 8))
        
        // Pre-allocate: header (227) + pointCount * 26 bytes
        data.reserveCapacity(227 + pointCount * 26)
        data.append(header)

        // í¬ì¸íŠ¸ ë°ì´í„° (Format 2: 26 bytes per point, RGB í¬í•¨)
        // Pre-allocate point data block for bulk writing
        var pointData = Data(count: pointCount * 26)
        pointData.withUnsafeMutableBytes { rawPtr in
            guard let base = rawPtr.baseAddress else { return }
            var offset = 0
            renderer.particlesBuffer.withUnsafeBufferPointer { buffer in
                let count = min(pointCount, buffer.count)
                for i in 0..<count {
                    let particle = buffer[i]
                    let position = transformPosition(particle.position, with: startInverse)

                    // X, Y, Z as Int32 (scaled)
                    var xI = Int32((Double(position.x) - xOffset) / xScale)
                    var yI = Int32((Double(position.y) - yOffset) / yScale)
                    var zI = Int32((Double(position.z) - zOffset) / zScale)
                    memcpy(base + offset, &xI, 4); offset += 4
                    memcpy(base + offset, &yI, 4); offset += 4
                    memcpy(base + offset, &zI, 4); offset += 4

                    // Intensity (UInt16)
                    var intensity: UInt16 = 255
                    memcpy(base + offset, &intensity, 2); offset += 2

                    // Return flags, classification, scan angle, user data (4 bytes)
                    (base + offset).storeBytes(of: UInt8(0x01), as: UInt8.self); offset += 1
                    (base + offset).storeBytes(of: UInt8(1), as: UInt8.self); offset += 1
                    (base + offset).storeBytes(of: Int8(0), as: Int8.self); offset += 1
                    (base + offset).storeBytes(of: UInt8(0), as: UInt8.self); offset += 1

                    // Point Source ID (UInt16)
                    var psid: UInt16 = 0
                    memcpy(base + offset, &psid, 2); offset += 2

                    // RGB (UInt16 each, 0-65535)
                    let colors = particle.color
                    var r16 = UInt16(max(0, min(1, colors.x)) * 65535.0)
                    var g16 = UInt16(max(0, min(1, colors.y)) * 65535.0)
                    var b16 = UInt16(max(0, min(1, colors.z)) * 65535.0)
                    memcpy(base + offset, &r16, 2); offset += 2
                    memcpy(base + offset, &g16, 2); offset += 2
                    memcpy(base + offset, &b16, 2); offset += 2
                }
            }
        }
        data.append(pointData)

        let elapsed = CFAbsoluteTimeGetCurrent() - startTime
        print("âœ… LAS ì™„ë£Œ â€” \(String(format: "%.2f", elapsed))ì´ˆ, \(data.count) bytes")

        return data
    }
}

// MARK: - Helpers

private extension PointCloudExporter {
    static func appendLine(_ line: String, to data: inout Data) {
        let stringWithNewline = line + "\n"
        if let lineData = stringWithNewline.data(using: .utf8) {
            data.append(lineData)
        }
    }
    
    static func renderParticles(renderer: Renderer, count: Int, _ handler: (Int, ParticleUniforms) -> Void) {
        renderer.particlesBuffer.withUnsafeBufferPointer { buffer in
            let clampedCount = min(count, buffer.count)
            for index in 0..<clampedCount {
                handler(index, buffer[index])
            }
        }
    }

    private static func clampColorComponent(_ value: Float) -> Int {
        return Int(max(0, min(1, value)) * 255.0)
    }
    
    private static func transformPosition(_ position: SIMD3<Float>, with inverse: simd_float4x4?) -> SIMD3<Float> {
        guard let inverse else { return position }
        let vector = SIMD4<Float>(position.x, position.y, position.z, 1.0)
        let transformed = inverse * vector
        return SIMD3<Float>(transformed.x, transformed.y, transformed.z)
    }
}
